# بررسی پروسه سناریوهای برخور فاجعه

به بررسی دو سناریو فاجعه‌ی ممکن و نحوه مقابله با آنان می‌پردازیم.

## سناریوی اول: مشکل ناگهانی و بحرانی در انتشار

در این مثال فرض می‌کنیم که لحظاتی‌ست که محصول منتشر شده است و در آن باگی را مشاهده می‌کنیم. در این موقعیت بایستی که در سریع‌ترین حالت ممکن، 
سیستم را به یک نسخه استیبل و پایدار، بازگدانی کنیم. برای این مثال می‌توان با دو روش زیر از فاجعه جلوگیری کرد..

### روش اول - با استفاده از سیستم rollback

در این روش، کافیست که کد `rollback.sh` را اجرا کنیم. این اسکریت به صورت خودکار محصول را به آخرین نسخه پایدار تعریف شده بازمیگرداند. نکته مهم در این شرایط اهمیت برخورد فعالانه (Active) به مبحث فاجعه به جای برخورد منفعلانه (Passive) می‌باشد.


###  روش دوم - با استفاده از فرایند تشخیص خودکار

در این روش بایستی که مراحل زیر را بپیماییم. فرض بر این است که از قبل روش rollback را پیاده‌سازی نکرده‌ایم.

- مرحله ۱: شناسایی آخرین نسخه پایدار 

برای پیدا کردن نسخه‌های منتشرشده، می‌توان از Git tags استفاده کرد:

```
git fetch --tags
git tag --sort=-v:refname | head -n 5
```

خروجی نمونه:

```
v1.2.0
v1.1.0
v1.0.0
```
آخرین نسخه پایدار v1.2.0 است.

- مرحله ۲: ایجاد اسکریپت بازگشت به نسخه پایدار (Recovery.sh) 

این اسکریپت فرآیند بازگشت را به‌صورت خودکار انجام می‌دهد.

```
#!/bin/bash


REPO_PATH= SE_Lab_project1

# ورود به مخزن

cd $REPO_PATH || { echo "خطا: مخزن یافت نشد!"; exit 1; }

# دریافت آخرین تغییرات

git fetch --tags

# دریافت آخرین نسخه پایدار

LAST_STABLE_VERSION=$(git tag --sort=-v:refname | head -n 1)

if [ -z "$LAST_STABLE_VERSION" ]; then
    echo "هیچ نسخه پایداری یافت نشد! خروج از اسکریپت."
    exit 1
fi

echo "در حال بازگشت به نسخه $LAST_STABLE_VERSION..."

# بازگشت به آخرین نسخه پایدار

git checkout $LAST_STABLE_VERSION

# راه‌اندازی مجدد سرویس (در صورت نیاز)

sudo systemctl restart my_app || echo "هشدار: راه‌اندازی مجدد سرویس ناموفق بود."

echo "بازگشت انجام شد! سیستم به نسخه $LAST_STABLE_VERSION بازگردانده شد."
```

- مرحله ۳: اجرای اسکریپت و تأیید بازگشت


```
bash recovery.sh
```

بررسی نسخه بازیابی‌شده:

```
git describe --tags
```

- مرحله ۴: ثبت لاگ بازیابی


```
echo "$(date) - Rolled back to $LAST_STABLE_VERSION" >> rollback.log
```

- مرحله ۵: اعمال تغییرات روی مخزن اصلی


```
git push origin main --force
```


## سناریوی دوم: مقابله با فساد داده یا Data Corruption

 در این مثال فرض می‌کنیم یک مهاجرت دیتابیس ناموفق باعث خرابی یا فساد در داده‌ شده است. در این شرایط، می‌توانیم مراحل زیر را بپیماییم.

- مرحله ۱: توقف سرویس‌ها
 ابتدا باید برای جلوگیری از تخریب بیشتر، برنامه را متوقف کنید:

```
sudo systemctl stop my_app
```

- مرحله ۲: شناسایی آخرین بکاپ سالم
بررسی لیست بکاپ‌های موجود:
bash
Copy
Edit
ls -lt /backups | head -n 5
خروجی نمونه:
diff
Copy
Edit
-rw-r--r--  1 user  user  250M Mar 18 12:00 db_backup_2024-03-18.sql
-rw-r--r--  1 user  user  245M Mar 17 12:00 db_backup_2024-03-17.sql
مرحله ۳: بازگردانی دیتابیس از بکاپ سالم
استفاده از آخرین بکاپ سالم برای بازگردانی:

```
pg_restore -U myuser -d mydatabase /backups/db_backup_2024-03-18.sql
```

- مرحله ۴: بازگرداندن مهاجرت دیتابیس معیوب
لیست کردن مهاجرت‌های اخیر:

```
ls migrations/
```

بازگرداندن مهاجرت مشکل‌دار:

```
python manage.py migrate app_name previous_migration
```

- مرحله ۵: بازگردانی آخرین تغییرات کد با Git

مشاهده تاریخچه کامیت‌ها:

```
git log --oneline --graph
```

بازگردانی نرم یا سخت به کامیت قبلی:

```
git revert HEAD --no-commit
```

```
git reset --hard HEAD~1
```

- مرحله ۶: راه‌اندازی مجدد سرویس‌ها

```
sudo systemctl start my_app
```

- مرحله ۷: بررسی صحت داده‌ها
بررسی لاگ‌ها:

```
tail -f /var/log/my_app.log
```

اجرای یک کوئری تستی:

```
SELECT COUNT(*) FROM users;
```
